---
/**
 * Desktop.astro - Main desktop container component
 * Displays blog posts as icons in a grid layout (macOS-inspired)
 * Phase 4: Added Dock component
 */
import { getCollection } from "astro:content";
import DesktopIcon from "./DesktopIcon.astro";
import Dock from "./Dock.astro";
import ContextMenu from "./ContextMenu.astro";
import MenuBar from "./MenuBar.astro";
import type { Post } from "@/scripts/desktop/file-system";

// Get all published posts
const posts = await getCollection("posts", ({ data }) => !data.draft);

// Convert to Post format for file system
const postsData = posts.map((post) => ({
  slug: post.slug,
  title: post.data.title,
  series: post.data.series,
  pubDate: post.data.date ? post.data.date.toISOString() : new Date().toISOString(),
  tags: post.data.tags,
  coverImage: post.data.cover,
}));
---

<!-- IBM Plex Sans Font Import for Desktop View -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">

<div class="desktop-container">
  <!-- macOS Menu Bar -->
  <MenuBar />

  <!-- Desktop background -->
  <div class="desktop-background"></div>

  <!-- Windows container (dynamically populated) -->
  <div id="desktop-windows-container"></div>

  <!-- Icon grid for files and folders (dynamically rendered by script) -->
  <div class="desktop-icons-grid" id="desktop-icons-container">
    <!-- Icons will be rendered dynamically by the script -->
  </div>

  <!-- Folder view container (shown when opening a folder) -->
  <div id="desktop-folder-container" class="hidden">
    <!-- Folder view will be rendered dynamically by the script -->
  </div>

  <!-- Hidden posts data for script to use -->
  <script type="application/json" id="posts-data" set:html={JSON.stringify(postsData)}></script>

  <!-- Message for mobile/small screens -->
  <div class="desktop-mobile-message">
    <div class="message-content">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
        <line x1="8" y1="21" x2="16" y2="21"></line>
        <line x1="12" y1="17" x2="12" y2="21"></line>
      </svg>
      <h2>Desktop View</h2>
      <p>Desktop view works best on larger screens (1024px+).</p>
      <p>Please switch to terminal view or use a desktop browser.</p>
    </div>
  </div>

  <!-- Dock - macOS-style navigation bar -->
  <Dock />

  <!-- Context Menu - Right-click menu for files and folders -->
  <ContextMenu />
</div>

<style>
  .desktop-container {
    position: relative;
    width: 100%;
    min-height: 100vh;
    overflow: hidden;
  }

  .desktop-background {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    /* macOS wallpaper image */
    background: url('/images/desktop/wallpaper.jpg') center/cover no-repeat;
    z-index: -1;
  }

  .desktop-background::after {
    content: '';
    position: absolute;
    inset: 0;
    /* Very subtle vignette */
    background: radial-gradient(ellipse 100% 100% at 50% 50%, transparent 60%, rgba(0, 0, 0, 0.1) 100%);
    pointer-events: none;
  }

  .desktop-icons-grid {
    position: relative;
    z-index: 1; /* Below windows */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 2rem;
    padding: 72px 48px 120px 48px;
    max-width: 100%;
    margin: 0 auto;
  }

  /* Mobile message - shown on small screens */
  .desktop-mobile-message {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(255, 255, 255, 0.98);
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  .message-content {
    text-align: center;
    padding: 2rem;
    color: #1d1d1f;
  }

  .message-content svg {
    margin: 0 auto 1rem;
    color: #007AFF;
  }

  .message-content h2 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    color: #1d1d1f;
  }

  .message-content p {
    margin-bottom: 0.5rem;
    color: #86868b;
  }

  /* Show mobile message on small screens */
  @media (max-width: 1023px) {
    .desktop-mobile-message {
      display: flex;
    }

    .desktop-icons-grid {
      display: none;
    }
  }

  /* Responsive grid for larger screens */
  @media (min-width: 1024px) {
    .desktop-icons-grid {
      grid-template-columns: repeat(auto-fill, minmax(100px, 100px));
      padding: 3rem;
    }
  }

  @media (min-width: 1440px) {
    .desktop-icons-grid {
      grid-template-columns: repeat(auto-fill, minmax(100px, 100px));
      padding: 4rem;
    }
  }

  /* View transition animations */
  :global(.view-exit) {
    animation: fadeOut 500ms ease-in-out forwards;
  }

  :global(.view-enter) {
    animation: fadeIn 500ms ease-in-out forwards;
  }

  @keyframes fadeOut {
    from {
      opacity: 1;
      transform: scale(1);
    }
    to {
      opacity: 0;
      transform: scale(0.98);
    }
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: scale(1.02);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  :global(.hidden) {
    display: none !important;
  }

  /* Windows container */
  #desktop-windows-container {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 100;
  }

  #desktop-windows-container > * {
    pointer-events: auto;
  }

  /* Folder view container */
  #desktop-folder-container {
    position: absolute;
    inset: 0;
    z-index: 10;
  }

  /* Folder view styles */
  :global(.folder-view) {
    position: absolute;
    inset: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    overflow-y: auto;
    animation: folderSlideIn 0.3s ease-out forwards;
  }

  @keyframes folderSlideIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  :global(.folder-header) {
    position: sticky;
    top: 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1.5rem 2rem;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    z-index: 20;
  }

  :global(.back-button) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 0.5rem;
    color: #1d1d1f;
    font-family: var(--font-primary);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  :global(.back-button:hover) {
    background: rgba(0, 122, 255, 0.1);
    border-color: rgba(0, 122, 255, 0.3);
    color: #007AFF;
  }

  :global(.back-button:active) {
    transform: scale(0.98);
  }

  :global(.folder-title) {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex: 1;
    color: #1d1d1f;
    font-family: var(--font-primary);
    font-size: 1.25rem;
    font-weight: 600;
  }

  :global(.folder-title svg) {
    color: #007AFF;
    flex-shrink: 0;
  }

  :global(.folder-info) {
    color: #86868b;
    font-family: var(--font-primary);
    font-size: 0.875rem;
  }

  :global(.folder-contents) {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 100px));
    gap: 2rem;
    padding: 2rem 3rem;
  }

  @media (max-width: 1023px) {
    :global(.folder-contents) {
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      padding: 2rem;
    }

    :global(.folder-header) {
      padding: 1rem;
    }

    :global(.folder-title) {
      font-size: 1rem;
    }
  }

  /* Folder grid inside windows */
  :global(.window-folder-grid) {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 100px));
    gap: 2rem;
    padding: 1rem;
  }

  /* File icon styles for folder windows */
  :global(.window-folder-grid .file-icon) {
    position: relative;
    width: 64px;
    height: 64px;
  }

  :global(.window-folder-grid .file-body) {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, #ffffff 0%, #f3f4f6 100%);
    border: 1.5px solid var(--desktop-border-medium);
    border-radius: 0.5rem;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  :global(.window-folder-grid .file-corner) {
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0 12px 12px 0;
    border-color: transparent var(--desktop-accent-primary) transparent transparent;
    border-radius: 0 0.5rem 0 0;
  }

  :global(.window-folder-grid .icon-preview) {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  :global(.window-folder-grid .file-lines) {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    padding: 0.75rem;
    width: 100%;
  }

  :global(.window-folder-grid .file-lines .line) {
    height: 2px;
    background: var(--desktop-border-medium);
    border-radius: 1px;
  }

  :global(.window-folder-grid .file-lines .line:nth-child(1)) {
    width: 80%;
  }

  :global(.window-folder-grid .file-lines .line:nth-child(2)) {
    width: 60%;
  }

  :global(.window-folder-grid .file-lines .line:nth-child(3)) {
    width: 70%;
  }

  :global(.window-folder-grid .file-extension) {
    position: absolute;
    bottom: -6px;
    right: -6px;
    background: var(--desktop-bg-primary);
    color: var(--desktop-accent-primary);
    font-size: 0.625rem;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    border: 1px solid var(--desktop-accent-primary);
    font-family: var(--font-primary);
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
</style>

<script>
  import { windowManager } from '@/scripts/desktop/window-manager';
  import type { WindowState } from '@/scripts/desktop/window-manager';
  import { buildFileSystem, getItemsForPath, getParentPath, isRootPath, getBreadcrumb } from '@/scripts/desktop/file-system';
  import type { Post, FileSystem } from '@/scripts/desktop/file-system';

  // Desktop state
  let currentPath = '~';
  let fileSystem: FileSystem;

  // Cleanup registry for window event listeners (prevents memory leaks)
  const windowCleanup = new Map<string, () => void>();

  // Listen for window open events from icons
  function setupDesktopWindowManager() {
    // Load posts data from script tag
    const postsDataEl = document.getElementById('posts-data');
    if (!postsDataEl) {
      console.error('Posts data not found');
      return;
    }

    try {
      const posts: Post[] = JSON.parse(postsDataEl.textContent || '[]');
      fileSystem = buildFileSystem(posts);

      // Initial render
      renderDesktop();
    } catch (error) {
      console.error('Failed to parse posts data:', error);
      return;
    }

    // Subscribe to window manager state changes - only handle add/remove, not position updates
    let previousWindowIds = new Set<string>();
    windowManager.subscribe((state) => {
      const currentWindowIds = new Set(state.windows.map(w => w.id));
      
      // Check if windows were added or removed
      const added = state.windows.filter(w => !previousWindowIds.has(w.id));
      const removed = [...previousWindowIds].filter(id => !currentWindowIds.has(id));
      
      if (added.length > 0 || removed.length > 0) {
        // Only re-render if windows were added or removed
        renderWindows(state.windows);
        previousWindowIds = currentWindowIds;
      }
    });

    // Listen for custom events to open windows
    document.addEventListener('desktop:open-post', ((event: CustomEvent) => {
      const { slug, title } = event.detail;
      openPostWindow(slug, title);
    }) as EventListener);

    // Listen for folder open events
    document.addEventListener('desktop:open-folder', ((event: CustomEvent) => {
      const { series, title } = event.detail;
      openFolder(series);
    }) as EventListener);

    // Listen for navigate back events
    document.addEventListener('desktop:navigate-back', (() => {
      navigateBack();
    }) as EventListener);

    // Listen for dock navigation events
    document.addEventListener('dock:navigate-home', (() => {
      navigateToRoot();
    }) as EventListener);

    // Note: Terminal switch is now handled directly by Dock using toggleView()

    // Setup keyboard navigation for icons
    setupKeyboardNavigation();

    // Setup keyboard shortcuts for windows (Escape/Cmd+W to close)
    setupWindowKeyboardShortcuts();

    // Subscribe to z-index changes to sync DOM
    windowManager.subscribe((state) => {
      state.windows.forEach(w => {
        const el = document.querySelector(`[data-window-id="${w.id}"]`) as HTMLElement;
        if (el && el.style.zIndex !== w.zIndex.toString()) {
          el.style.zIndex = w.zIndex.toString();
        }
      });
    });
  }

  function setupWindowKeyboardShortcuts() {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle if desktop view is visible
      const desktopContainer = document.querySelector('.desktop-view-container');
      if (desktopContainer?.classList.contains('hidden')) return;

      // Escape or Cmd/Ctrl+W to close focused window
      if (e.key === 'Escape' || ((e.metaKey || e.ctrlKey) && e.key === 'w')) {
        const topWindow = getTopWindow();
        if (topWindow) {
          e.preventDefault();
          closeWindowWithAnimation(topWindow.el as HTMLElement, topWindow.id);
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
  }

  function getTopWindow(): { el: Element; id: string } | null {
    const windows = windowManager.getAllWindows();
    if (windows.length === 0) return null;

    const topState = windows.reduce((a, b) => (a.zIndex > b.zIndex ? a : b));
    const el = document.querySelector(`[data-window-id="${topState.id}"]`);
    return el ? { el, id: topState.id } : null;
  }

  function renderDesktop() {
    const items = getItemsForPath(currentPath, fileSystem);
    const iconsContainer = document.getElementById('desktop-icons-container');
    const folderContainer = document.getElementById('desktop-folder-container');

    if (!iconsContainer || !folderContainer) return;

    if (isRootPath(currentPath)) {
      // Show icons grid, hide folder view
      iconsContainer.classList.remove('hidden');
      folderContainer.classList.add('hidden');
      renderIcons(items);
    } else {
      // Show folder view, hide icons grid
      iconsContainer.classList.add('hidden');
      folderContainer.classList.remove('hidden');
      renderFolderView();
    }
  }

  function renderIcons(items: any[]) {
    const container = document.getElementById('desktop-icons-container');
    if (!container) return;

    container.innerHTML = '';

    items.forEach((item) => {
      const iconEl = document.createElement('div');
      iconEl.className = 'desktop-icon';
      iconEl.setAttribute('data-type', item.type);
      iconEl.setAttribute('role', 'button');
      iconEl.setAttribute('tabindex', '0');
      iconEl.setAttribute('aria-label', `${item.type === 'file' ? 'Post' : 'Folder'}: ${item.name}`);

      if (item.type === 'file') {
        iconEl.setAttribute('data-post', item.slug || '');
      } else {
        iconEl.setAttribute('data-folder', item.series || '');
      }

      const displayTitle = item.name.length > 20 ? item.name.substring(0, 17) + '...' : item.name;

      iconEl.innerHTML = `
        <div class="icon-visual">
          ${item.type === 'file' ? `
            <div class="file-icon">
              <div class="file-body">
                ${item.coverImage ? `
                  <img src="${item.coverImage}" alt="" class="icon-preview" />
                ` : `
                  <div class="file-lines">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                  </div>
                `}
              </div>
              <div class="file-corner"></div>
              <div class="file-extension">.md</div>
            </div>
          ` : `
            <div class="folder-icon">
              <div class="folder-body"></div>
              <div class="folder-tab"></div>
            </div>
          `}
        </div>
        <div class="icon-label">${displayTitle}</div>
        ${item.type === 'folder' && item.postCount ? `
          <div class="folder-metadata">${item.postCount} ${item.postCount === 1 ? 'post' : 'posts'}</div>
        ` : ''}
        ${item.tags && item.tags.length > 0 ? `
          <div class="icon-metadata">
            ${item.tags.slice(0, 3).map((tag: string, idx: number) => `
              <span class="tag-dot" title="${tag}"></span>
            `).join('')}
          </div>
        ` : ''}
      `;

      container.appendChild(iconEl);
    });

    // Re-setup icon interactions after rendering
    setupIconInteractions();
  }

  function renderFolderView() {
    const container = document.getElementById('desktop-folder-container');
    if (!container) return;

    // Extract series name from path
    const match = currentPath.match(/^~\/series\/(.+)$/);
    if (!match) return;

    const seriesName = decodeURIComponent(match[1]);
    const folder = fileSystem.folders.find((f) => f.series === seriesName);

    if (!folder || !folder.posts) return;

    container.innerHTML = `
      <div class="folder-view">
        <div class="folder-header">
          <button class="back-button" aria-label="Back to desktop">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="19" y1="12" x2="5" y2="12"></line>
              <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
            <span>Back</span>
          </button>

          <div class="folder-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
            </svg>
            <span>${folder.name}</span>
          </div>

          <div class="folder-info">
            ${folder.posts.length} ${folder.posts.length === 1 ? 'post' : 'posts'}
          </div>
        </div>

        <div class="folder-contents" id="folder-contents-grid">
          <!-- Posts will be rendered here -->
        </div>
      </div>
    `;

    // Render posts in folder
    const postsContainer = container.querySelector('#folder-contents-grid');
    if (postsContainer) {
      folder.posts.forEach((post) => {
        const iconEl = document.createElement('div');
        iconEl.className = 'desktop-icon';
        iconEl.setAttribute('data-type', 'file');
        iconEl.setAttribute('data-post', post.slug);
        iconEl.setAttribute('role', 'button');
        iconEl.setAttribute('tabindex', '0');
        iconEl.setAttribute('aria-label', `Post: ${post.title}`);

        const displayTitle = post.title.length > 20 ? post.title.substring(0, 17) + '...' : post.title;

        iconEl.innerHTML = `
          <div class="icon-visual">
            <div class="file-icon">
              <div class="file-body">
                ${post.coverImage ? `
                  <img src="${post.coverImage}" alt="" class="icon-preview" />
                ` : `
                  <div class="file-lines">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                  </div>
                `}
              </div>
              <div class="file-corner"></div>
              <div class="file-extension">.md</div>
            </div>
          </div>
          <div class="icon-label">${displayTitle}</div>
        `;

        postsContainer.appendChild(iconEl);
      });
    }

    // Setup back button
    const backButton = container.querySelector('.back-button');
    if (backButton) {
      backButton.addEventListener('click', () => {
        navigateBack();
      });
    }

    // Setup icon interactions in folder
    setupIconInteractions();
  }

  function setupIconInteractions() {
    const icons = document.querySelectorAll('.desktop-icon');

    icons.forEach((icon) => {
      // Remove old listeners by cloning
      const newIcon = icon.cloneNode(true) as HTMLElement;
      icon.parentNode?.replaceChild(newIcon, icon);

      // Double-click handler
      newIcon.addEventListener('dblclick', () => {
        const type = newIcon.getAttribute('data-type');
        const slug = newIcon.getAttribute(type === 'file' ? 'data-post' : 'data-folder');

        if (type === 'file' && slug) {
          const title = newIcon.querySelector('.icon-label')?.textContent?.trim() || 'Untitled';
          const event = new CustomEvent('desktop:open-post', {
            detail: { slug, title },
            bubbles: true,
          });
          document.dispatchEvent(event);
        } else if (type === 'folder' && slug) {
          const event = new CustomEvent('desktop:open-folder', {
            detail: { series: slug, title: newIcon.querySelector('.icon-label')?.textContent?.trim() },
            bubbles: true,
          });
          document.dispatchEvent(event);
        }
      });

      // Single-click to select
      newIcon.addEventListener('click', (e) => {
        if (!e.ctrlKey && !e.metaKey) {
          document.querySelectorAll('.desktop-icon.selected').forEach((selected) => {
            selected.classList.remove('selected');
          });
        }
        newIcon.classList.toggle('selected');
      });

      // Keyboard support
      newIcon.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          newIcon.dispatchEvent(new Event('dblclick'));
        }
      });
    });
  }

  function openFolder(series: string) {
    const folder = fileSystem.folders.find(f => f.series === series);
    if (!folder) return;

    windowManager.openFolderWindow(series, folder.name);
    // Window rendering is handled by the subscription
  }

  function navigateBack() {
    currentPath = getParentPath(currentPath);
    renderDesktop();
  }

  function navigateToRoot() {
    currentPath = '~';
    renderDesktop();
  }

  function setupKeyboardNavigation() {
    let selectedIndex = -1;

    document.addEventListener('keydown', (e) => {
      // Only handle keyboard when desktop is visible and not in a window or context menu
      const desktopVisible = !document.querySelector('.terminal-view-container:not(.view-exit)');
      const contextMenuVisible = !document.getElementById('context-menu')?.classList.contains('hidden');
      const windowFocused = document.activeElement?.closest('.desktop-window');

      if (!desktopVisible || contextMenuVisible || windowFocused) return;

      const icons = Array.from(document.querySelectorAll('.desktop-icon'));
      if (icons.length === 0) return;

      switch (e.key) {
        case 'ArrowRight':
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % icons.length;
          selectIcon(icons, selectedIndex);
          break;

        case 'ArrowLeft':
          e.preventDefault();
          selectedIndex = selectedIndex <= 0 ? icons.length - 1 : selectedIndex - 1;
          selectIcon(icons, selectedIndex);
          break;

        case 'ArrowDown':
          e.preventDefault();
          // Move down in grid (approximate 8 items per row)
          const itemsPerRow = Math.floor(window.innerWidth / 140) || 8;
          selectedIndex = Math.min(selectedIndex + itemsPerRow, icons.length - 1);
          selectIcon(icons, selectedIndex);
          break;

        case 'ArrowUp':
          e.preventDefault();
          // Move up in grid
          const itemsPerRowUp = Math.floor(window.innerWidth / 140) || 8;
          selectedIndex = Math.max(selectedIndex - itemsPerRowUp, 0);
          selectIcon(icons, selectedIndex);
          break;

        case 'Enter':
        case ' ':
          e.preventDefault();
          if (selectedIndex >= 0 && selectedIndex < icons.length) {
            const icon = icons[selectedIndex] as HTMLElement;
            icon.dispatchEvent(new Event('dblclick'));
          }
          break;

        case 'Backspace':
          e.preventDefault();
          if (!isRootPath(currentPath)) {
            navigateBack();
            selectedIndex = -1;
          }
          break;

        case 'Escape':
          e.preventDefault();
          // Deselect all
          icons.forEach((icon) => icon.classList.remove('selected'));
          selectedIndex = -1;
          break;
      }
    });
  }

  function selectIcon(icons: Element[], index: number) {
    // Clear previous selection
    icons.forEach((icon) => icon.classList.remove('selected'));

    // Select new icon
    if (index >= 0 && index < icons.length) {
      const icon = icons[index] as HTMLElement;
      icon.classList.add('selected');
      icon.focus({ preventScroll: false });

      // Scroll into view if needed
      icon.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }

  function openPostWindow(slug: string, title: string) {
    windowManager.openWindow(slug, title);
    // Window rendering is handled by the subscription
  }

  function renderWindows(windows: WindowState[]) {
    const container = document.getElementById('desktop-windows-container');
    if (!container) return;

    // Clear and re-render all windows
    container.innerHTML = '';

    windows.forEach((window) => {
      const windowEl = createWindowElement(window);
      container.appendChild(windowEl);
    });

    // Re-initialize window scripts after rendering
    // Trigger a custom event that the window script can listen to
    const event = new CustomEvent('windows-rendered');
    document.dispatchEvent(event);
  }

  function createWindowElement(state: WindowState): HTMLElement {
    const div = document.createElement('div');
    div.className = 'desktop-window';
    div.setAttribute('data-window-id', state.id);
    div.setAttribute('data-window-type', state.windowType);
    if (state.postSlug) {
      div.setAttribute('data-post-slug', state.postSlug);
    }
    if (state.folderSeries) {
      div.setAttribute('data-folder-series', state.folderSeries);
    }
    div.style.cssText = `
      left: ${state.position.x}px;
      top: ${state.position.y}px;
      width: ${state.size.width}px;
      height: ${state.size.height}px;
      z-index: ${state.zIndex};
    `;

    div.innerHTML = `
      <div class="window-titlebar" data-draggable="true">
        <div class="traffic-lights">
          <button class="traffic-light traffic-light-close" aria-label="Close window" data-action="close">
            <svg width="12" height="12" viewBox="0 0 12 12">
              <line x1="3" y1="3" x2="9" y2="9" stroke="currentColor" stroke-width="1.5" />
              <line x1="9" y1="3" x2="3" y2="9" stroke="currentColor" stroke-width="1.5" />
            </svg>
          </button>
          <button class="traffic-light traffic-light-minimize" aria-label="Minimize window" data-action="minimize" disabled>
            <svg width="12" height="12" viewBox="0 0 12 12">
              <line x1="3" y1="6" x2="9" y2="6" stroke="currentColor" stroke-width="1.5" />
            </svg>
          </button>
          <button class="traffic-light traffic-light-maximize" aria-label="Maximize window" data-action="maximize" disabled>
            <svg width="12" height="12" viewBox="0 0 12 12">
              <polyline points="3,5 3,3 9,3 9,9 7,9" fill="none" stroke="currentColor" stroke-width="1.5" />
              <polyline points="5,7 5,9 9,9" fill="none" stroke="currentColor" stroke-width="1.5" />
            </svg>
          </button>
        </div>
        <div class="window-title">${escapeHtml(state.title)}</div>
        <div class="traffic-lights-spacer"></div>
      </div>
      <div class="window-content">
        <div class="window-loading">
          <div class="spinner"></div>
          <p>${state.windowType === 'folder' ? 'Loading folder...' : 'Loading post...'}</p>
        </div>
        <div class="window-post-content hidden"></div>
      </div>
      <div class="resize-handle resize-handle-n" data-direction="n"></div>
      <div class="resize-handle resize-handle-s" data-direction="s"></div>
      <div class="resize-handle resize-handle-e" data-direction="e"></div>
      <div class="resize-handle resize-handle-w" data-direction="w"></div>
      <div class="resize-handle resize-handle-ne" data-direction="ne"></div>
      <div class="resize-handle resize-handle-nw" data-direction="nw"></div>
      <div class="resize-handle resize-handle-se" data-direction="se"></div>
      <div class="resize-handle resize-handle-sw" data-direction="sw"></div>
    `;

    // Setup window interactions
    setupWindowInteractions(div, state.id);

    // Load content based on window type
    if (state.windowType === 'post' && state.postSlug) {
      loadPostContent(div, state.postSlug);
    } else if (state.windowType === 'folder' && state.folderSeries) {
      loadFolderContent(div, state.folderSeries);
    }

    return div;
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function setupWindowInteractions(windowEl: HTMLElement, windowId: string) {
    // Close button
    const closeBtn = windowEl.querySelector('[data-action="close"]');
    closeBtn?.addEventListener('click', () => {
      closeWindowWithAnimation(windowEl, windowId);
    });

    // Maximize button
    const maximizeBtn = windowEl.querySelector('[data-action="maximize"]');
    maximizeBtn?.removeAttribute('disabled');
    maximizeBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMaximize(windowEl, windowId);
    });

    // Bring to front on click and sync z-index
    windowEl.addEventListener('mousedown', () => {
      windowManager.bringToFront(windowId);
      // Immediately update DOM z-index
      const state = windowManager.getWindow(windowId);
      if (state) {
        windowEl.style.zIndex = state.zIndex.toString();
      }
    });

    // Setup dragging
    setupDragging(windowEl, windowId);

    // Setup resizing
    setupResizing(windowEl, windowId);
  }

  function closeWindowWithAnimation(windowEl: HTMLElement, windowId: string) {
    // Call cleanup before removing
    windowCleanup.get(windowId)?.();
    windowCleanup.delete(windowId);

    windowEl.style.animation = 'windowClose 0.2s ease-in forwards';
    setTimeout(() => {
      windowManager.closeWindow(windowId);
    }, 200);
  }

  function toggleMaximize(windowEl: HTMLElement, windowId: string) {
    const state = windowManager.getWindow(windowId);
    if (!state) return;

    if (state.isMaximized) {
      // Restore previous position/size
      const prev = state.preMaximizeState;
      if (prev) {
        windowEl.style.left = `${prev.position.x}px`;
        windowEl.style.top = `${prev.position.y}px`;
        windowEl.style.width = `${prev.size.width}px`;
        windowEl.style.height = `${prev.size.height}px`;
        windowManager.updatePosition(windowId, prev.position);
        windowManager.updateSize(windowId, prev.size);
      }
    } else {
      // Store current state and maximize
      windowManager.setPreMaximizeState(windowId, state.position, state.size);
      const menuBarHeight = 28;
      const dockHeight = 80;
      windowEl.style.left = '0';
      windowEl.style.top = `${menuBarHeight}px`;
      windowEl.style.width = '100vw';
      windowEl.style.height = `calc(100vh - ${menuBarHeight}px - ${dockHeight}px)`;
      windowManager.updatePosition(windowId, { x: 0, y: menuBarHeight });
      windowManager.updateSize(windowId, { width: window.innerWidth, height: window.innerHeight - menuBarHeight - dockHeight });
    }
    windowManager.toggleMaximize(windowId);
  }

  function setupDragging(windowEl: HTMLElement, windowId: string) {
    const titlebar = windowEl.querySelector('.window-titlebar');
    if (!titlebar) return;

    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let initialX = 0;
    let initialY = 0;

    const handleTitlebarMouseDown = (e: Event) => {
      const mouseEvent = e as MouseEvent;
      if ((mouseEvent.target as HTMLElement).closest('.traffic-light')) return;

      // Check if window is maximized - don't allow drag
      const state = windowManager.getWindow(windowId);
      if (state?.isMaximized) return;

      isDragging = true;
      startX = mouseEvent.clientX;
      startY = mouseEvent.clientY;

      const rect = windowEl.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;

      windowEl.style.cursor = 'grabbing';
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      const newX = Math.max(0, Math.min(initialX + deltaX, window.innerWidth - windowEl.offsetWidth));
      const newY = Math.max(28, Math.min(initialY + deltaY, window.innerHeight - windowEl.offsetHeight)); // 28px for menu bar

      windowEl.style.left = `${newX}px`;
      windowEl.style.top = `${newY}px`;

      windowManager.updatePosition(windowId, { x: newX, y: newY });
    };

    const handleMouseUp = () => {
      if (isDragging) {
        isDragging = false;
        windowEl.style.cursor = '';
      }
    };

    titlebar.addEventListener('mousedown', handleTitlebarMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Register cleanup function
    const cleanup = () => {
      titlebar.removeEventListener('mousedown', handleTitlebarMouseDown);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };

    // Add to existing cleanup or create new
    const existingCleanup = windowCleanup.get(windowId);
    windowCleanup.set(windowId, () => {
      existingCleanup?.();
      cleanup();
    });
  }

  function setupResizing(windowEl: HTMLElement, windowId: string) {
    const MIN_WIDTH = 400;
    const MIN_HEIGHT = 300;
    const handles = windowEl.querySelectorAll('.resize-handle');
    const resizeCleanups: (() => void)[] = [];

    handles.forEach((handle) => {
      let isResizing = false;
      let startX = 0;
      let startY = 0;
      let startWidth = 0;
      let startHeight = 0;
      let startLeft = 0;
      let startTop = 0;
      const direction = handle.getAttribute('data-direction') || '';

      const handleHandleMouseDown = (e: Event) => {
        const mouseEvent = e as MouseEvent;
        e.preventDefault();
        e.stopPropagation();

        // Check if window is maximized - don't allow resize
        const state = windowManager.getWindow(windowId);
        if (state?.isMaximized) return;

        isResizing = true;
        startX = mouseEvent.clientX;
        startY = mouseEvent.clientY;

        const rect = windowEl.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;

        document.body.style.cursor = getComputedStyle(handle as Element).cursor;
      };

      const handleMouseMove = (e: MouseEvent) => {
        if (!isResizing) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;

        // Calculate new dimensions based on direction
        if (direction.includes('e')) {
          newWidth = Math.max(MIN_WIDTH, startWidth + deltaX);
        }
        if (direction.includes('w')) {
          newWidth = Math.max(MIN_WIDTH, startWidth - deltaX);
          if (newWidth > MIN_WIDTH) {
            newLeft = startLeft + deltaX;
          }
        }
        if (direction.includes('s')) {
          newHeight = Math.max(MIN_HEIGHT, startHeight + deltaY);
        }
        if (direction.includes('n')) {
          newHeight = Math.max(MIN_HEIGHT, startHeight - deltaY);
          if (newHeight > MIN_HEIGHT) {
            newTop = startTop + deltaY;
          }
        }

        // Ensure window stays within viewport bounds
        const maxWidth = window.innerWidth - newLeft;
        const maxHeight = window.innerHeight - newTop;
        newWidth = Math.min(newWidth, maxWidth);
        newHeight = Math.min(newHeight, maxHeight);

        // Apply new dimensions
        windowEl.style.width = `${newWidth}px`;
        windowEl.style.height = `${newHeight}px`;
        windowEl.style.left = `${newLeft}px`;
        windowEl.style.top = `${newTop}px`;

        // Update window manager state
        windowManager.updatePosition(windowId, { x: newLeft, y: newTop });
        windowManager.updateSize(windowId, { width: newWidth, height: newHeight });
      };

      const handleMouseUp = () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      };

      handle.addEventListener('mousedown', handleHandleMouseDown);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);

      // Store cleanup for this handle
      resizeCleanups.push(() => {
        handle.removeEventListener('mousedown', handleHandleMouseDown);
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      });
    });

    // Register all resize cleanups
    const existingCleanup = windowCleanup.get(windowId);
    windowCleanup.set(windowId, () => {
      existingCleanup?.();
      resizeCleanups.forEach(cleanup => cleanup());
    });
  }

  async function loadPostContent(windowEl: HTMLElement, postSlug: string) {
    const contentEl = windowEl.querySelector('.window-post-content');
    const loadingEl = windowEl.querySelector('.window-loading');

    try {
      const response = await fetch(`/posts/${postSlug}`);
      if (!response.ok) throw new Error('Failed to load post');

      const html = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const articleContent = doc.querySelector('article')?.innerHTML || doc.querySelector('main')?.innerHTML;

      if (contentEl && articleContent) {
        contentEl.innerHTML = articleContent;
        loadingEl?.classList.add('hidden');
        contentEl.classList.remove('hidden');
      }
    } catch (error) {
      console.error('Error loading post:', error);
      if (contentEl) {
        contentEl.innerHTML = '<p style="color: #ef4444">Failed to load post content.</p>';
        loadingEl?.classList.add('hidden');
        contentEl.classList.remove('hidden');
      }
    }
  }

  function loadFolderContent(windowEl: HTMLElement, folderSeries: string) {
    const contentEl = windowEl.querySelector('.window-post-content');
    const loadingEl = windowEl.querySelector('.window-loading');

    try {
      const folder = fileSystem.folders.find(f => f.series === folderSeries);
      if (!folder || !folder.posts) {
        throw new Error('Folder not found');
      }

      // Create folder grid content
      const gridContainer = document.createElement('div');
      gridContainer.className = 'window-folder-grid';

      folder.posts.forEach((post) => {
        const iconEl = document.createElement('div');
        iconEl.className = 'desktop-icon';
        iconEl.setAttribute('data-type', 'file');
        iconEl.setAttribute('data-post', post.slug);
        iconEl.setAttribute('role', 'button');
        iconEl.setAttribute('tabindex', '0');
        iconEl.setAttribute('aria-label', `Post: ${post.title}`);

        const displayTitle = post.title.length > 20 ? post.title.substring(0, 17) + '...' : post.title;

        iconEl.innerHTML = `
          <div class="icon-visual">
            <div class="file-icon">
              <div class="file-body">
                ${post.coverImage ? `
                  <img src="${post.coverImage}" alt="" class="icon-preview" />
                ` : `
                  <div class="file-lines">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                  </div>
                `}
              </div>
              <div class="file-corner"></div>
              <div class="file-extension">.md</div>
            </div>
          </div>
          <div class="icon-label">${escapeHtml(displayTitle)}</div>
        `;

        gridContainer.appendChild(iconEl);
      });

      if (contentEl) {
        contentEl.innerHTML = '';
        contentEl.appendChild(gridContainer);
        loadingEl?.classList.add('hidden');
        contentEl.classList.remove('hidden');

        // Setup icon interactions for posts in folder window
        setupFolderWindowIconInteractions(contentEl);
      }
    } catch (error) {
      console.error('Error loading folder:', error);
      if (contentEl) {
        contentEl.innerHTML = '<p style="color: #ef4444">Failed to load folder content.</p>';
        loadingEl?.classList.add('hidden');
        contentEl.classList.remove('hidden');
      }
    }
  }

  function setupFolderWindowIconInteractions(container: Element) {
    const icons = container.querySelectorAll('.desktop-icon');

    icons.forEach((icon) => {
      // Double-click to open post
      icon.addEventListener('dblclick', () => {
        const slug = icon.getAttribute('data-post');
        if (slug) {
          const title = icon.querySelector('.icon-label')?.textContent?.trim() || 'Untitled';
          openPostWindow(slug, title);
        }
      });

      // Single-click to select
      icon.addEventListener('click', (e: Event) => {
        const mouseEvent = e as MouseEvent;
        if (!mouseEvent.ctrlKey && !mouseEvent.metaKey) {
          container.querySelectorAll('.desktop-icon.selected').forEach((selected) => {
            selected.classList.remove('selected');
          });
        }
        icon.classList.toggle('selected');
      });

      // Keyboard support
      icon.addEventListener('keydown', (e: Event) => {
        const keyEvent = e as KeyboardEvent;
        if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
          e.preventDefault();
          icon.dispatchEvent(new Event('dblclick'));
        }
      });
    });
  }

  // Track if already initialized to prevent duplicate event listeners
  let isInitialized = false;

  function initDesktop() {
    if (isInitialized) {
      // Already initialized - just re-render desktop
      if (fileSystem) {
        renderDesktop();
      }
      return;
    }
    isInitialized = true;
    setupDesktopWindowManager();
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDesktop);
  } else {
    initDesktop();
  }

  document.addEventListener('astro:page-load', initDesktop);
</script>
